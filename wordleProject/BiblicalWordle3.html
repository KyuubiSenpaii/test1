<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biblical Wordle</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configure Tailwind for custom colors and fonts -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'wordle-green': '#6AAA64',
                        'wordle-yellow': '#C9B458',
                        'wordle-gray': '#787C7E',
                        'wordle-dark-gray': '#3A3A3C',
                        'wordle-light-gray': '#D3D6DA',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            background-color: #1F2937; /* Dark background */
            font-family: 'Inter', sans-serif;
        }
        /* Grid cell dimensions for responsiveness */
        .grid-cell {
            width: 3.5rem;
            height: 3.5rem;
            /* Adjust size for mobile */
            @media (max-width: 640px) {
                width: 3rem;
                height: 3rem;
                font-size: 1.5rem;
            }

            border: 2px solid #565758;
            font-size: 2rem;
            font-weight: 700;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s, background-color 0.6s, border-color 0.6s;
            color: white;
            perspective: 1000px;
        }
        .filled {
            border-color: #787C7E;
        }
        /* Flip animation effect */
        .flip-in {
            transform: rotateX(90deg);
        }
        .flip-out {
            transform: rotateX(0deg);
        }
        /* Status styles */
        .status-G { 
            background-color: #6AAA64; /* Green */
            border-color: #6AAA64;
        }
        .status-Y { 
            background-color: #C9B458; /* Yellow */
            border-color: #C9B458;
        }
        .status-X { 
            background-color: #787C7E; /* Gray */
            border-color: #787C7E;
        }

        .key {
            padding: 0.5rem 0.75rem;
            min-width: 2rem;
            height: 3.5rem;
            border-radius: 0.375rem;
            background-color: #818384;
            color: white;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s;
        }
        .key:hover {
            background-color: #929495;
        }
        .key-G { background-color: #6AAA64 !important; }
        .key-Y { background-color: #C9B458 !important; }
        .key-X { background-color: #3A3A3C !important; }

        /* Custom Modal Styling for Alert/Confirm */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center pt-8 md:pt-12">

    <!-- Header -->
    <header class="w-full max-w-lg mb-6 border-b border-gray-700 pb-2">
        <h1 class="text-3xl font-bold text-center text-white">
            <span class="text-wordle-yellow">Biblical</span> Wordle
        </h1>
    </header>

    <!-- Game Grid Container -->
    <main id="game-container" class="flex flex-col items-center">
        <!-- FIX: Removed grid-cols-5 from this container and let the JS create 6 stacked rows. -->
        <div id="wordle-grid" class="flex flex-col gap-1.5 p-4 bg-gray-900 rounded-lg shadow-2xl">
            <!-- Dynamic content -->
        </div>
    </main>

    <!-- Custom Message/Alert Box -->
    <div id="message-box" class="fixed top-20 bg-gray-700 text-white px-4 py-2 rounded-lg shadow-xl opacity-0 transition-opacity duration-300 pointer-events-none">
        <!-- Messages appear here -->
    </div>

    <!-- Modal for Game Over / Play Again (Custom Alert) -->
    <div id="game-over-modal" class="modal flex items-center justify-center">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl max-w-sm w-11/12 text-white text-center">
            <h2 id="modal-title" class="text-3xl font-bold mb-4 text-wordle-green"></h2>
            <p id="modal-message" class="mb-6 text-lg"></p>
            <button id="modal-new-game-btn" class="bg-wordle-green hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200">
                Play Again
            </button>
        </div>
    </div>

    <!-- On-Screen Keyboard -->
    <section id="keyboard" class="w-full max-w-xl mt-8 p-4">
        <!-- Keyboard will be generated here by JavaScript -->
        <div class="space-y-2">
            <!-- Row 1 -->
            <div class="flex justify-center space-x-1">
                <div class="key" data-key="Q">Q</div>
                <div class="key" data-key="W">W</div>
                <div class="key" data-key="E">E</div>
                <div class="key" data-key="R">R</div>
                <div class="key" data-key="T">T</div>
                <div class="key" data-key="Y">Y</div>
                <div class="key" data-key="U">U</div>
                <div class="key" data-key="I">I</div>
                <div class="key" data-key="O">O</div>
                <div class="key" data-key="P">P</div>
            </div>
            <!-- Row 2 -->
            <div class="flex justify-center space-x-1">
                <div class="key" data-key="A">A</div>
                <div class="key" data-key="S">S</div>
                <div class="key" data-key="D">D</div>
                <div class="key" data-key="F">F</div>
                <div class="key" data-key="G">G</div>
                <div class="key" data-key="H">H</div>
                <div class="key" data-key="J">J</div>
                <div class="key" data-key="K">K</div>
                <div class="key" data-key="L">L</div>
            </div>
            <!-- Row 3 -->
            <div class="flex justify-center space-x-1">
                <div class="key key-enter" data-key="ENTER">ENTER</div>
                <div class="key" data-key="Z">Z</div>
                <div class="key" data-key="X">X</div>
                <div class="key" data-key="C">C</div>
                <div class="key" data-key="V">V</div>
                <div class="key" data-key="B">B</div>
                <div class="key" data-key="N">N</div>
                <div class="key" data-key="M">M</div>
                <div class="key key-delete" data-key="BACKSPACE">âŒ«</div>
            </div>
        </div>
    </section>

    <script>
        // --- GAME CONFIGURATION ---
        const WORD_LENGTH = 5;
        const MAX_ATTEMPTS = 6;
        const BIBLICAL_WORDS = [
            "AARON", "ABDON", "ABNER", "ABRAM", "ADINA", "ADLAI", "ALLON", "AMASA", "AMNON", 
            "ANANI", "ASHER", "ATARA", "AZIZA", "AZZAN", "BARAK", "BELAH", "BERIA", "CALEB", 
            "CARMI", "CHLOE", "DAVID", "DINAH", "ELIAH", "ELIKA", "ENOCH", "FELIX", "HAGAR", 
            "HIRAM", "ISAAC", "JABEZ", "JADAU", "JAMES", "JESSE", "JESUS", "JOASH", "JOBAB", 
            "JONAH", "JUDAH", "JUNIA", "LABAN", "LINUS", "LOTAN", "LUCAS", "MARIA", "MICAH", 
            "MOSES", "NAOMI", "NERIA", "PALLU", "PETER", "RAHAB", "RHODA", "SALMA", "SARAH", 
            "SHELA", "SHEMA", "SIMON", "TALAH", "TAMAR", "TERAH", "TITUS", "URIAH", "URBAN", 
            "ZERAH", "ZEROR"
        ];
        // Note: The list of words is based on the final verified list from the Java code.

        // --- GAME STATE ---
        let secretWord = '';
        let currentGuess = '';
        let currentRow = 0;
        let isGameOver = false;

        // --- DOM ELEMENTS ---
        const grid = document.getElementById('wordle-grid');
        const messageBox = document.getElementById('message-box');
        const modal = document.getElementById('game-over-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalNewGameBtn = document.getElementById('modal-new-game-btn');

        // --- CORE FUNCTIONS ---

        /**
         * Selects a random word from the list and initializes the game state.
         */
        function initializeGame() {
            const randomIndex = Math.floor(Math.random() * BIBLICAL_WORDS.length);
            secretWord = BIBLICAL_WORDS[randomIndex];
            currentGuess = '';
            currentRow = 0;
            isGameOver = false;

            // Clear and rebuild the grid and keyboard
            grid.innerHTML = '';
            createGrid();
            updateKeyboardColors(true); // Reset keyboard colors

            // Hide modal and message box
            modal.style.display = 'none';
            messageBox.style.opacity = '0';
        }

        /**
         * Generates the 6 rows of 5 cells (6x5 grid).
         */
        function createGrid() {
            for (let r = 0; r < MAX_ATTEMPTS; r++) {
                const row = document.createElement('div');
                // The main wordle-grid div is now flex flex-col.
                // We make each row a flex container with horizontal spacing (space-x-1.5)
                row.className = 'flex space-x-1.5'; 
                for (let c = 0; c < WORD_LENGTH; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.setAttribute('id', `cell-${r}-${c}`);
                    row.appendChild(cell);
                }
                grid.appendChild(row);
            }
        }

        /**
         * Handles user input from the physical or on-screen keyboard.
         * @param {string} key - The key that was pressed.
         */
        function handleInput(key) {
            if (isGameOver) return;

            if (key === 'ENTER') {
                submitGuess();
            } else if (key === 'BACKSPACE') {
                deleteLetter();
            } else if (key.length === 1 && key.match(/[A-Z]/i)) {
                addLetter(key.toUpperCase());
            }
        }

        /**
         * Adds a letter to the current guess in the grid.
         * @param {string} letter - The letter to add.
         */
        function addLetter(letter) {
            if (currentGuess.length < WORD_LENGTH) {
                currentGuess += letter;
                const cell = document.getElementById(`cell-${currentRow}-${currentGuess.length - 1}`);
                if (cell) {
                    cell.textContent = letter;
                    cell.classList.add('filled');
                }
            }
        }

        /**
         * Removes the last letter from the current guess.
         */
        function deleteLetter() {
            if (currentGuess.length > 0) {
                const cellIndex = currentGuess.length - 1;
                const cell = document.getElementById(`cell-${currentRow}-${cellIndex}`);
                if (cell) {
                    cell.textContent = '';
                    cell.classList.remove('filled');
                }
                currentGuess = currentGuess.slice(0, -1);
            }
        }

        /**
         * Submits the current guess for validation and feedback.
         */
        function submitGuess() {
            if (currentGuess.length !== WORD_LENGTH) {
                showMessage("Not enough letters!", 1500);
                return;
            }

            // In a real app, you would check against a dictionary of valid guesses.
            // Since we don't have a large guess dictionary, we proceed with the check.
            
            checkGuess(currentGuess);
        }

        /**
         * Compares the guess against the secret word and provides feedback.
         * @param {string} guess - The user's 5-letter guess.
         */
        function checkGuess(guess) {
            const feedback = new Array(WORD_LENGTH).fill('X'); // X = Gray
            const secretLetters = secretWord.split('');

            // 1. First Pass: Find correct letters in the correct position (GREEN)
            for (let i = 0; i < WORD_LENGTH; i++) {
                if (guess[i] === secretWord[i]) {
                    feedback[i] = 'G'; // Green
                    secretLetters[i] = null; // Mark letter as consumed
                }
            }

            // 2. Second Pass: Find correct letters in the wrong position (YELLOW)
            for (let i = 0; i < WORD_LENGTH; i++) {
                if (feedback[i] !== 'G') {
                    const yellowIndex = secretLetters.indexOf(guess[i]);
                    if (yellowIndex !== -1) {
                        feedback[i] = 'Y'; // Yellow
                        secretLetters[yellowIndex] = null; // Mark letter as consumed
                    }
                }
            }
            
            // Apply feedback to the grid and keyboard
            applyFeedbackToGrid(guess, feedback);
            updateKeyboardColors(false, guess, feedback);

            // Check for Win/Loss
            if (guess === secretWord) {
                isGameOver = true;
                setTimeout(() => showGameOverModal(true), 2000); // Delay for animation
            } else if (currentRow === MAX_ATTEMPTS - 1) {
                isGameOver = true;
                setTimeout(() => showGameOverModal(false), 2000); // Delay for animation
            } else {
                // Move to the next row for the next guess
                currentRow++;
                currentGuess = '';
            }
        }

        /**
         * Applies the color feedback to the guess row with a flipping animation.
         * @param {string} guess - The user's guess.
         * @param {string[]} feedback - Array of feedback ('G', 'Y', 'X').
         */
        function applyFeedbackToGrid(guess, feedback) {
            for (let i = 0; i < WORD_LENGTH; i++) {
                const cell = document.getElementById(`cell-${currentRow}-${i}`);
                if (cell) {
                    // Start flip animation
                    setTimeout(() => {
                        cell.classList.add('flip-in');
                        cell.style.transform = 'rotateX(90deg)';
                    }, i * 300); // Stagger the start of the flip

                    // Change color and flip back after half the animation time
                    setTimeout(() => {
                        cell.classList.add(`status-${feedback[i]}`);
                        cell.classList.remove('flip-in');
                        cell.classList.add('flip-out');
                        cell.style.transform = 'rotateX(0deg)';
                    }, i * 300 + 150); 
                }
            }
        }

        /**
         * Updates the color of keys on the virtual keyboard based on feedback.
         * @param {boolean} reset - If true, resets all keys to default gray.
         * @param {string} [guess] - The current guess (if not resetting).
         * @param {string[]} [feedback] - The feedback array (if not resetting).
         */
        function updateKeyboardColors(reset, guess = '', feedback = []) {
            const keys = document.querySelectorAll('#keyboard .key');
            keys.forEach(keyElement => {
                const letter = keyElement.getAttribute('data-key');
                if (letter === 'ENTER' || letter === 'BACKSPACE') return;

                if (reset) {
                    keyElement.className = 'key'; // Reset all classes
                } else {
                    // Find the best status for the key based on the letters used in the guess
                    let bestStatus = 'X'; 
                    for (let i = 0; i < WORD_LENGTH; i++) {
                        if (guess[i] === letter) {
                            const status = feedback[i];
                            if (status === 'G') {
                                bestStatus = 'G'; 
                                break; // Green is the highest priority, stop checking
                            } else if (status === 'Y' && bestStatus !== 'G') {
                                bestStatus = 'Y';
                            } else if (status === 'X' && bestStatus !== 'G' && bestStatus !== 'Y') {
                                bestStatus = 'X';
                            }
                        }
                    }

                    let currentStatus = keyElement.classList.contains('key-G') ? 'G' : 
                                        keyElement.classList.contains('key-Y') ? 'Y' : 
                                        keyElement.classList.contains('key-X') ? 'X' : 
                                        '';
                    
                    // Only update if the new status is better than the current one
                    const statusOrder = ['X', 'Y', 'G'];
                    if (statusOrder.indexOf(bestStatus) > statusOrder.indexOf(currentStatus)) {
                        keyElement.classList.remove('key-G', 'key-Y', 'key-X');
                        keyElement.classList.add(`key-${bestStatus}`);
                    }
                }
            });
        }


        /**
         * Displays a temporary message to the user.
         * @param {string} message - The message text.
         * @param {number} duration - How long the message should be visible in ms.
         */
        function showMessage(message, duration = 2000) {
            messageBox.textContent = message;
            messageBox.style.opacity = '1';
            setTimeout(() => {
                messageBox.style.opacity = '0';
            }, duration);
        }

        /**
         * Displays the game over modal (win or lose).
         * @param {boolean} didWin - True if the player won, false otherwise.
         */
        function showGameOverModal(didWin) {
            modal.style.display = 'flex';
            if (didWin) {
                modalTitle.textContent = "Congratulations!";
                modalMessage.textContent = `You guessed the word: ${secretWord}!`;
                modalTitle.className = 'text-3xl font-bold mb-4 text-wordle-green';
                modalNewGameBtn.className = 'bg-wordle-green hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200';
            } else {
                modalTitle.textContent = "Game Over";
                modalMessage.textContent = `The word was: ${secretWord}. Better luck next time!`;
                modalTitle.className = 'text-3xl font-bold mb-4 text-wordle-yellow';
                modalNewGameBtn.className = 'bg-wordle-yellow hover:bg-yellow-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200';
            }
        }

        // --- EVENT LISTENERS ---

        // Listen for physical keyboard input
        document.addEventListener('keydown', (event) => {
            const key = event.key.toUpperCase();
            if (key === 'ENTER' || key === 'BACKSPACE' || (key.length === 1 && key.match(/[A-Z]/i))) {
                // Prevent default behavior for Enter and Backspace to avoid browser navigation/form submission issues
                if (key === 'ENTER' || key === 'BACKSPACE') {
                    event.preventDefault();
                }
                handleInput(key);
            }
        });

        // Listen for on-screen keyboard input
        document.getElementById('keyboard').addEventListener('click', (event) => {
            const keyElement = event.target.closest('.key');
            if (keyElement) {
                const key = keyElement.getAttribute('data-key');
                handleInput(key);
            }
        });

        // Listen for the "Play Again" button click
        modalNewGameBtn.addEventListener('click', initializeGame);

        // --- INITIALIZATION ---
        window.onload = initializeGame;

    </script>
</body>
</html>
